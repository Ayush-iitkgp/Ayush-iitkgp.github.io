<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns#
article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>"\n", | Ayush Pandey</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://Ayush-iitkgp.github.io/stories/gsoc16-proposal/">
<!--[if lt IE 9]>
            <script src="../../assets/js/html5shiv.min.js"></script>
            <script src="../../assets/js/respond.min.js"></script>
        <![endif]--><meta name="author" content="Ayush Pandey">
<meta property="og:site_name" content="Ayush Pandey">
<meta property="og:title" content='"\n",'>
<meta property="og:url" content="http://Ayush-iitkgp.github.io/stories/gsoc16-proposal/">
<meta property="og:description" content="About Me¶Username and Contact Information¶Name            :   Ayush Pandey
University      :   Indian Institute of Technology (IIT), Kharagpur
Email           :   ayush.pandey@iitkgp.ac.in
IRC Handle ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-07-25T21:31:28.384130+05:30">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-success header-panel shadow-z-3" role="navigation"><div class="container-fluid">
        <div class="row">
          <div class="col-xs-3">
            <h1 class="title-blog">
                <a href="http://Ayush-iitkgp.github.io/">
                        <span id="blog-title">Ayush Pandey</span>
                    </a>
            </h1>
          </div>
        </div>
      </div>
<!-- /.container-fluid -->
</nav><div class="container-fluid main" id="content" role="main">
        <div class="row">
            <nav class="col-xs-3 menu"><ul>
<li class="withripple"><a href="../../galleries">Gallery</a></li>
            <li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">GSoC'16<b class="caret"></b></a>
            <ul class="dropdown-menu">
<li><a href="http://nbviewer.jupyter.org/github/Ayush-iitkgp/GSoc-Proposal/blob/master/GSoC%202016%20Application%20Ayush%20Pandey-%20Support%20for%20complex%20numbers%20within%20Convex.jl.ipynb">Proposal</a></li>
                    <li><a href="../../2016">Blog</a></li>
                    <li><a href="../juliacon.slides.html/">JuliaCon2016 Presentation</a></li>
                    <li><a href="stories/juliacon-2016-talk">Talk</a></li>
            </ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Internships<b class="caret"></b></a>
            <ul class="dropdown-menu">
<li><a href="https://drive.google.com/open?id=0B2oOdWdSJWa1YUJGTjNGdTNoRGVkNHNkcmRoRDZCd2ozSFk0">Samsung</a></li>
                    <li><a href="https://drive.google.com/open?id=0B2oOdWdSJWa1UE41cHlCZEdZOTQ">Flutura</a></li>
            </ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown">Projects<b class="caret"></b></a>
            <ul class="dropdown-menu">
<li><a href="https://drive.google.com/open?id=0B2oOdWdSJWa1dFhTWHpWczgwTkZ0Vy1DTFVxVm9rYjlxeU1R">Portfolio Optimization</a></li>
                    <li><a href="../../">Theft Analyics</a></li>
            </ul>
</li>
<li class="withripple"><a href="https://drive.google.com/open?id=0B2oOdWdSJWa1Y185TVRTc0xSMGs">Resume</a></li>

                    
                </ul>
<ul class="nav navbar-nav"></ul></nav><div class="posts-material col-xs-9">
                <div class="col-xs-12 col-md-11 content-material">
<article class="post-text storypage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">"\n",</a></h1>
<hr></header><div class="e-content entry-content" itemprop="articleBody text">
    <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="About-Me">About Me<a class="anchor-link" href="#About-Me">¶</a>
</h2>
<h3 id="Username-and-Contact-Information">Username and Contact Information<a class="anchor-link" href="#Username-and-Contact-Information">¶</a>
</h3>
<p><strong>Name</strong>            :   Ayush Pandey</p>
<p><strong>University</strong>      :   <a href="http://iitkgp.ac.in">Indian Institute of Technology (IIT), Kharagpur</a></p>
<p><strong>Email</strong>           :   ayush.pandey@iitkgp.ac.in</p>
<p><strong>IRC Handle</strong>      :   KrishnaKanhaiya at freenode.net</p>
<p><strong>Github Username</strong> :   <a href="https://github.com/Ayush-iitkgp">Ayush-iitkgp</a></p>
<h3 id="Personal-Background">Personal Background<a class="anchor-link" href="#Personal-Background">¶</a>
</h3>
<p>Hello, I am Ayush Pandey, a 4th year undergraduate student pursuing an Integrated Master of Science(MS) degree in Mathematics and Computing Sciences with micro-specialization in Optimization Theory and Applications
at IIT Kharagpur, India. I am proficient in C, C++, Java and Python. I am moderately proficient in Julia.</p>
<h3 id="Previous-Relevant-Experience">Previous Relevant Experience<a class="anchor-link" href="#Previous-Relevant-Experience">¶</a>
</h3>
<p>My first encounter with the field of optimization and operation research was during my 3rd year in the college when I took a course in Operation Research. As a part of the course, we were asked to code the Linear Programming methods (<a href="https://github.com/Ayush-iitkgp/Linear-Programming">source code</a>). I enjoyed the course a lot and since then have been reading optimization. I was also chosen to be a part of the IIT Kharagpur's contingent in <a href="http://interiittech.com/">4th InterIIT TechMeet</a> where IIT Kharagpur won gold medal in Portfolio Optimization event in which the participants had to present the solution for the Cardinality Constrained Efficient Frontier which we solved using 3 heuristic methods namely Genetic Algorithm, Tabu Search and Simulated Annealing (<a href="https://github.com/Ayush-iitkgp/InterIIT-TechMeet">source code</a>).</p>
<p>In the ongoing semester, I am also taking a course on Non-Linear Programming where I am reading and programming (<a href="https://github.com/Ayush-iitkgp/Non-Linear-Programming">source code</a>) in MATLAB the optimization techniques like golden-section method, Nelder-Mead Simplex method and derivative methods such as steepest descent and Newton method for unconstrained optimization and penalty function, interior point method for constrained optimization.</p>
<h3 id="Relevant-Courses">Relevant Courses<a class="anchor-link" href="#Relevant-Courses">¶</a>
</h3>
<ul>
<li>Operation Research (Theory and Lab)</li>
<li>Non-Linear Programming (ongoing)</li>
<li>Convex Optimization (ongoing)</li>
<li>Linear Algebra, Programming and Data Structures, Object Oriented System Design</li>
</ul>
<h3 id="Answers-of-listed-questions">Answers of listed questions<a class="anchor-link" href="#Answers-of-listed-questions">¶</a>
</h3>
<p><code>1. What do you want to have completed by the end of the program?</code></p>
<p>By the end of the program, I want to add support for complex-domain optimization problem in Convex.jl which presently supports only real-domain optimization problems.</p>
<p><code>2. Who’s interested in the work, and how will it benefit them?</code></p>
<p>Many problems in applied sciences are posed as optimization problems over the complex field such as Phase retrieval from sparse signals, or designing an FIR filter given a desired frequency response. The present approach is to manually convert the complex-domain problems to real-domain problems (<a href="http://nbviewer.jupyter.org/github/cvxgrp/cvxpy/blob/master/examples/notebooks/WWW/fir_chebychev_design.ipynb">example</a>) and pass to solvers. The correct approach to such problem is to make existing packages like Convex.jl deal with complex-domain problems directly without converting them to real-domain problem.</p>
<p><code>3. What are the potential hurdles you might encounter, and how can you resolve them?</code></p>
<p>I already satisfy the requirements for the project.</p>
<p><code>4. How will you prioritise different aspects of the project like features, API usability, documentation and robustness?</code></p>
<p>Please refer to the "Timeline" section where I have described in details about my plans to tackle different aspects of the project.</p>
<p><code>5. Does your project have any milestones that you can target throughout the period?</code></p>
<p>Yes, at the the end of week 8, the support for the complex-domain problems would be ready for testing for the Julia community.</p>
<p><code>6. Are there any stretch goals you can make if the main project goes smoothly?</code></p>
<p>Yes, I do plan to publish a research paper under the guidance of my mentors by the end of the GSoc period.</p>
<p><code>7. What other time commitments, such as summer courses, other jobs, planned vacations, etc., will you have over the summer?</code></p>
<p>I expect to work full time on the project that is 40 or more hours a week. I have no other commitments in the summer as of now.</p>
<h3 id="Contribution-to-Open-Source-Projects">Contribution to Open-Source Projects<a class="anchor-link" href="#Contribution-to-Open-Source-Projects">¶</a>
</h3>
<ul>
<li>(<strong>Merged</strong>) <code>Added solution Unconstrained Markowitz Efficient Frontier example.</code><a href="https://github.com/JuliaOpt/Convex.jl/pull/128">#128</a>
</li>
</ul>
<ul>
<li>(<strong>Open</strong>) <code>Added sdp examples.</code><a href="https://github.com/JuliaOpt/Convex.jl/pull/129">#129</a>
</li>
</ul>
<ul>
<li>(<strong>Merged</strong>) <code>Corrected Pass to solver: stuff matrices objective function.</code><a href="https://github.com/JuliaCon/presentations/pull/9">#9</a>
</li>
</ul>
<h3 id="Experience-with-Julia">Experience with Julia<a class="anchor-link" href="#Experience-with-Julia">¶</a>
</h3>
<p>I have been using Julia for last one and half month. In terms of functionality, I like Julia because of its <strong>multiple dispatch</strong> feature as it lets me overload operators with a lot of ease than other programming languages.</p>
<p>But the most astonishing feature of Julia is that it is empowering. In other high-level languages, the users can not be developers because developing new packages in those language require the users to know the intricacies of low-level language whereas in Julia, users can develop packages for their needs in Julia itself without compromising with the speed.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Project">The Project<a class="anchor-link" href="#The-Project">¶</a>
</h2>
<h3 id="The-Problem-and-Motivations">The Problem and Motivations<a class="anchor-link" href="#The-Problem-and-Motivations">¶</a>
</h3>
<p>The aim of the project is to add support for solving complex domain optimization problems in Convex.jl (a Julia package for Disciplined Convex Programming).</p>
<p>Many problems in applied sciences are posed as optimization problems over the complex field such as:</p>
<ul>
<li>Phase retrieval from sparse signals</li>
<li>Designing an FIR filter given a desired frequency response</li>
<li>Optimization problems in AC power systems</li>
<li>Frequency domain analysis in signal processing and control theory.</li>
</ul>
<p>The present approach is to manually convert the complex-domain problems to real-domain problems (<a href="http://nbviewer.jupyter.org/github/cvxgrp/cvxpy/blob/master/examples/notebooks/WWW/fir_chebychev_design.ipynb">example</a>) and pass to solvers. This process can be time consuming and non-intuitive sometimes. The correct approach to such problem is to make existing packages deal with complex-domain problems. Thus, during this summer, I aim to implement the support for complex-domain optimization problems in Convex.jl.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Plan">The Plan<a class="anchor-link" href="#The-Plan">¶</a>
</h2>
<p>I propose to implement required functionality in Convex.jl so that it could accept and solve the complex-domain optimization problems without having the users to explicitly convert the complex problems to real-domain optimization problems. I plan to implement a 6 step procedure to support complex-domain optimization problems within Convex.jl:</p>
<ol>
<li>Add support for complex variables and complex SDPs in Convex.jl </li>
<li>Provide the users of the package with the option to express complex SDP in user-friendly language</li>
<li>Implement the infrastructure to convert the complex SDP to real SDP internally</li>
<li>Solve the real SDP using existing backend solvers via the MathProgBase interface</li>
<li>Convert the solution of the real SDP into corresponding complex SDP</li>
<li>Output the complex domain solution to the user</li>
</ol>
<p>I also aim to publish the work done during this period under the guidance of my mentors.</p>
<h3 id="Mathematical-Formulation">Mathematical Formulation<a class="anchor-link" href="#Mathematical-Formulation">¶</a>
</h3>
<p>First of all, we need to understand the mathematical formulation of complex-domain optimization problems before we get into the implementation details.</p>
<h4 id="Definitions">Definitions<a class="anchor-link" href="#Definitions">¶</a>
</h4>
<p><strong>Hermitian Matrix -</strong> A matrix $X \in \mathbf{C}^{n \times n}$ is hermitian if $X = X^*$ where $X^*$ is the conjugate transpose of the $X$.</p>
<p><strong>Complex Positive Semidefinite Matrix -</strong> A matrix $X \in \mathbf{C}^{n \times n}$ is positive semidefinite, we write as 
$X \succeq 0$ if for all column vectors $\alpha \in \mathbf{C}^n$, we have</p>
<p>$\alpha^T X \alpha \geq$ 0</p>
<p><strong>Notation -</strong> The inner product of two complex matrices $X$ and $Y$ is represented as &lt; $X,Y$ &gt;.</p>
<p><strong>Note -</strong> The inner product of two hermitian matrices &lt; $X,Y$ &gt; = $Tr(Y^*X$) = $Tr(XY$) and is always real.</p>
<h3 id="Complex-Semidefinite-Program">Complex Semidefinite Program<a class="anchor-link" href="#Complex-Semidefinite-Program">¶</a>
</h3>
<p>In a complex semidefinite programming, we maximize or minimize for an objective matrix $C$ which is Hermitian matrix subject to linear constraints on $X$ and the constraint that $X$ is complex positive semidefinite.</p>
<p>The canonical form of the Complex Semidefinite Programming Problem is:</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>minimize</strong></p>
<blockquote>
<p>&lt; $C,X$ &gt;</p>
</blockquote>
<p><strong>subject to</strong></p>
<blockquote>
<p>$X$ is Hermitian matrix</p>
<p>$X$ $\succeq 0$</p>
<p>&lt; $A_i,X$ &gt;    $\leq b_i$,            i = 1,2,.... m</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>where $A_1, A_2,....,A_m \in \mathbf{C}^{n \times n}$ and $C \in \mathbf{C}^{n \times n}$ are known Hermitian matrices, $b_1,....b_m \in \mathbf{R}$ are known numbers and $X \in \mathbf {C}^{n \times n}$ is the variable Hermitian matrix.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Execution">Execution<a class="anchor-link" href="#Execution">¶</a>
</h2>
<p>The problem of complex optimization can be tackled using the bijective transformation $\tau $ from the ${C}^{n \times n}$ space to the ${R}^{2n \times 2n}$ space.</p>
<p>There is an reduction from complex semidefinite programs to semidefinite programs involving real matrices as 
a complex matrix $X \in {C}^{n \times n}$ defines a real matrix</p>
<p>         $\tau(X) = \left[\begin{array}{ccc}{Real}(X)&amp;{-Imaginary}(X)\\{Imaginary}(X)&amp;{Real}(X)\end{array}\right]$</p>
<p>where ${Real}(X) \in {R}^{n \times n}$ and ${Imaginary}(X) \in{R}^{n \times n}$ are the real and the imaginary parts of $X$.</p>
<p><strong>Note 1-</strong> If complex matrix $X \in {C}^{n \times n}$ is Hermitian then its transformation $\tau(X) \in {R}^{2n \times n}$ is positive semidefinite.</p>
<p><strong>Note 2-</strong> For two hermitian matrices $X,Y$</p>
<p>&lt; $\tau(X), \tau(Y) &gt; = Tr( \left[\begin{array}{ccc}{Real}(Y)&amp;{-Imaginary}(Y)\\{Imaginary}(Y)&amp;{Real}(Y)\end{array}\right]$$\left[\begin{array}{ccc}{Real}(X)&amp;{-Imaginary}(Y)\\{Imaginary}(X)&amp;{Real}(X)\end{array}\right]) = 2 
</p>
<p>After the transformation $\tau$, the properties of being Hermitian and complex positive semidefinite translate into symmetric and real positive semidefinite.</p>
<p><strong>Thus we have the corresponding real SDP:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>minimize</strong></p>
<blockquote>
<p>&lt; $\tau(C),Y$ &gt;</p>
</blockquote>
<p><strong>subject to </strong></p>
<blockquote>
<p>$Y$ is symmetric matrix of order $2n$</p>
<p>$Y \succeq 0$</p>
<p>$$   $\leq 2b_i$        i = 1,2,.... m</p>
<p>$Y = \left[\begin{array}{ccc}D&amp;-E\\E&amp;D\end{array}\right]$</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>where $D$ is a symmetric matrix of order n and $E$ is a skew-symmetric matrix of same order. Here $Y$ is the variable positive semidefinite matrix of order $2n$ and $\tau(A_i)$ i=1,2.....n are the transformation of the hermitian matrices $A_i$ i=1,2.....n appearing in canonical form of the complex semidefinite programming problem.</p>
<p><strong>Note- </strong> $\tau(Y) = X$, thus if $Y$ is feasible solution for the real SDP, then $\tau^{-1}(Y)= X$ is the feasible solution for the complex SDP and the <strong>value objective function of complex SDP is half that of real SDP</strong>.</p>
<p><strong>Hence solving the complex SDP is equivalent to solving the corresponding real SDP and transforming the value to complex domain</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="1.-Support-complex-variable-and-complex-SDP-in-Convex.jl">1. Support complex variable and complex SDP in Convex.jl<a class="anchor-link" href="#1.-Support-complex-variable-and-complex-SDP-in-Convex.jl">¶</a>
</h3>
<p>On the lines of the existing variable system in Convex.jl, I would implement 3 new variable types for supporting complex scalar, vector and hermitian positive semidefinite matrix. This would require me to append new variable type to variable.jl which would be a subtype of AbstractExpr.</p>
<p>This is the first step in supporting complex-domain optmization problem is to implement variablws of type complex. In order to acheive this, I have created a new subtype <strong>NotDefined</strong> of Abstract type <strong>"Sign"</strong>.</p>
<p><strong>Note-</strong> <em>It is important to note that there is difference between NoSign and NotDefined. For e.g.- Any real variable not assigned a sign initially has NoSign but there is no notion of sign for complex expression thus a complex expression has always a NotDefined entry in sign field.</em></p>
<p>I also introduced a new field called Domain (with two subtypes as Real and Complex) within user-defined types Variable(which will have Domain value always equal to Real). Similary, a new subtype of AbstractExpr was introduced which is called as "ComplexVariable" with the following characteristic different from "Variable":</p>
<ol>
<li>head field would take value "complex_variable".</li>
<li>Sign field would always have value as NotDefined()</li>
<li>Domain field would always have values as Complex.</li>
</ol>
<p>Also a new method doamin was defined which would display the domain field of the Variable or Complex Variable.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">type</span><span class="nc"> ComplexVariable</span> <span class="o">&lt;:</span> <span class="n">AbstractExpr</span>
  <span class="n">head</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">id_hash</span><span class="p">::</span><span class="n">UInt64</span>
  <span class="n">value</span><span class="p">::</span><span class="n">ValueOrNothing</span>     <span class="c">#ValueorNothing should support data of type 5+4im # We would need to redefine this</span>
  <span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">}</span>
  <span class="n">vexity</span><span class="p">::</span><span class="n">Vexity</span>
  <span class="n">sign</span><span class="p">::</span><span class="n">Sign</span>
  <span class="c"># New code</span>
  <span class="c"># New field called domain</span>
  <span class="n">domain</span><span class="p">::</span><span class="n">Domain</span>
  <span class="n">sets</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>


  <span class="k">function</span><span class="nf"> ComplexVariable</span><span class="p">(</span><span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">},</span> <span class="n">sign</span><span class="p">::</span><span class="n">Sign</span><span class="o">=</span><span class="n">NotDefined</span><span class="p">(),</span> <span class="n">domain</span><span class="p">::</span><span class="n">Domain</span><span class="o">=</span><span class="n">Complex</span><span class="p">(),</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span>
    <span class="n">this</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(:</span><span class="n">complex_variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nothing</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">AffineVexity</span><span class="p">(),</span> <span class="n">sign</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">[</span><span class="n">sets</span><span class="o">...</span><span class="p">])</span>
    <span class="n">this</span><span class="o">.</span><span class="n">id_hash</span> <span class="o">=</span> <span class="n">object_id</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
    <span class="n">id_to_complex_variables</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">id_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">this</span>
    <span class="k">return</span> <span class="n">this</span>
  <span class="k">end</span>

  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">m</span><span class="p">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">n</span><span class="p">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">sign</span><span class="p">::</span><span class="n">Sign</span><span class="o">=</span><span class="n">NotDefined</span><span class="p">(),</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">sign</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">NotDefined</span><span class="p">(),</span> <span class="n">domain</span><span class="p">,</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">sign</span><span class="p">::</span><span class="n">Sign</span><span class="o">=</span><span class="n">NotDefined</span><span class="p">(),</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sign</span><span class="p">,</span> <span class="n">Complex</span><span class="p">(),</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">},</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">NotDefined</span><span class="p">(),</span> <span class="n">Complex</span><span class="p">(),</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">size</span><span class="p">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">sign</span><span class="p">::</span><span class="n">Sign</span><span class="o">=</span><span class="n">NotDefined</span><span class="p">(),</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sign</span><span class="p">,</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
  <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">size</span><span class="p">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">sets</span><span class="p">::</span><span class="n">Symbol</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sets</span><span class="o">...</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">HermitianSemidefinite</span><span class="p">(</span><span class="n">m</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="p">:</span><span class="n">HermitianSemidefinite</span><span class="p">)</span>
<span class="k">function</span><span class="nf"> HermitianSemidefinite</span><span class="p">(</span><span class="n">m</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span class="n">n</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="n">n</span>
    <span class="k">return</span> <span class="n">ComplexVariable</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="p">:</span><span class="n">HermitianSemidefinite</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="nb">error</span><span class="p">(</span><span class="s">"HermitianSemidefinite matrices must be square"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">id_to_complex_variables</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">{</span><span class="n">UInt64</span><span class="p">,</span> <span class="n">ComplexVariable</span><span class="p">}()</span>

<span class="k">function</span><span class="nf"> vexity</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Variable</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">vexity</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Variable</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">nothing</span> <span class="o">?</span> <span class="nb">error</span><span class="p">(</span><span class="s">"Value of the variable is yet to be calculated"</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> sign</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Variable</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">sign</span>
<span class="k">end</span>

<span class="c"># Added new method to display domain of the variable</span>
<span class="k">function</span><span class="nf"> domain</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Variable</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">domain</span>
<span class="k">end</span>


<span class="c"># Add a new complex variable</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">()</span>

<span class="n">ComplexVariable</span> <span class="n">of</span>
<span class="p">:</span><span class="n">head</span><span class="p">:</span> <span class="n">complex</span>
<span class="p">:</span><span class="n">size</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">:</span><span class="n">sign</span><span class="p">:</span> <span class="n">NotDefined</span>
<span class="p">:</span><span class="n">vexity</span><span class="p">:</span> <span class="n">Convex</span><span class="o">.</span><span class="n">AffineVexity</span><span class="p">()</span>
<span class="p">:</span><span class="n">domain</span><span class="p">:</span> <span class="n">Complex</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">ComplexVariable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>        <span class="c"># n is the number of elements in complex vector</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">HermitianSemidefinite</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>    <span class="c"># n is the order the hermitian positive semidefinite matrix</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The above modifications allow us to declare the variables as real or complex but we also needed to redefine the constant.jl file to enable the constants to take complex value. This was done by adding a field called "domain" to the fields in Constant user-defined type.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">type</span><span class="nc"> Constant</span> <span class="o">&lt;:</span> <span class="n">AbstractExpr</span>
  <span class="n">head</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">id_hash</span><span class="p">::</span><span class="n">UInt64</span>
  <span class="n">value</span><span class="p">::</span><span class="n">Value</span>
  <span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">}</span>
  <span class="n">vexity</span><span class="p">::</span><span class="n">Vexity</span>
  <span class="n">sign</span><span class="p">::</span><span class="n">Sign</span>
  <span class="n">domain</span><span class="p">::</span><span class="n">Domain</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>new After we have introduced a new field in variable.jl and a new subtype of Sign, we were required to modify dcp.jl file that handles the basic rules on interactions(negate, addition and multiplication) of mathematical expressions to create new expressions. The present implemetation only handles the sign, the vexity and the monotonicity. I modified it to also handle whether an expression is real or complex.</p>
<p>The following new rules were added:</p>
<ol>
<li>Negative of NotDefined is NotDefined.</li>
<li>Negate operation does not change the domain.</li>
<li>Any sign + NotDefined = NotDefined</li>
<li>Any domain * Any Sign = NotDefined</li>
<li>Real * Real = Real</li>
<li>Any Domain * Complex Domain = Complex Domain</li>
</ol>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># Sign subtypes</span>
<span class="k">abstract</span><span class="nc"> Sign</span>
<span class="k">type</span><span class="nc"> Positive</span> <span class="o">&lt;:</span> <span class="n">Sign</span>                   <span class="k">end</span>
<span class="k">type</span><span class="nc"> Negative</span> <span class="o">&lt;:</span> <span class="n">Sign</span>                   <span class="k">end</span>
<span class="k">type</span><span class="nc"> NoSign</span> <span class="o">&lt;:</span> <span class="n">Sign</span>                     <span class="k">end</span>

<span class="c"># New code</span>
<span class="c"># Also create a new subtype of Sign "NotDefined to handle the complex case"</span>
<span class="k">type</span><span class="nc"> NotDefined</span> <span class="o">&lt;:</span> <span class="n">Sign</span>                 <span class="k">end</span>

<span class="c"># New code</span>
<span class="c"># Domain Subtypes</span>
<span class="k">abstract</span><span class="nc"> Domain</span>
<span class="k">type</span><span class="nc"> Real</span> <span class="o">&lt;:</span> <span class="n">Domain</span>                    <span class="k">end</span>
<span class="k">type</span><span class="nc"> Complex</span> <span class="o">&lt;:</span> <span class="n">Domain</span>                 <span class="k">end</span>

<span class="c"># Adding rule for Domain</span>
<span class="o">-</span><span class="p">(</span><span class="n">d</span><span class="p">::</span><span class="n">Domain</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span>

<span class="c"># Any sign + NotDefined = NotDefined</span>
<span class="o">+</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">Sign</span><span class="p">,</span> <span class="n">t</span><span class="p">::</span><span class="n">NotDefined</span><span class="p">)</span> <span class="o">=</span> <span class="n">t</span>

<span class="c"># Real/Complex + Complex = Complex</span>
<span class="o">+</span><span class="p">(</span><span class="n">d</span><span class="p">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">e</span><span class="p">::</span><span class="n">Complex</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span>
<span class="o">+</span><span class="p">(</span><span class="n">d</span><span class="p">::</span><span class="n">Complex</span><span class="p">,</span> <span class="n">e</span><span class="p">::</span><span class="n">Domain</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span>

<span class="c"># NotDefined * Any Sign = NotDefined(Though complex and its conjugate is real but we ignore that case)</span>
<span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="p">::</span><span class="n">NotDefined</span><span class="p">,</span> <span class="n">s</span><span class="p">::</span><span class="n">Sign</span><span class="p">)</span> <span class="o">=</span> <span class="n">t</span>
<span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">Sign</span><span class="p">,</span> <span class="n">t</span><span class="p">::</span><span class="n">NotDefined</span><span class="p">)</span> <span class="o">=</span> <span class="n">t</span>

<span class="c"># Real * Real = Real</span>
<span class="c"># Complex * Anything = Complex</span>
<span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">::</span><span class="n">Real</span><span class="p">,</span> <span class="n">e</span><span class="p">::</span><span class="n">Real</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span>
<span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">::</span><span class="n">Domain</span><span class="p">,</span> <span class="n">e</span><span class="p">::</span><span class="n">Complex</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The very important utility function we need is to check whether an expression is real or complex. Fortunately, this method would use the theory that we have developed in dcp. jl to check whether an expression is real or not.</p>
<p>In order to implement this method, we would have to redefine every atom. I think I wuld need to add 2 new fields to</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="2.-Provide-the-users-of-the-package-with-the-option-to-express-complex-SDP-in-user-friendly-language">2. Provide the users of the package with the option to express complex SDP in user-friendly language<a class="anchor-link" href="#2.-Provide-the-users-of-the-package-with-the-option-to-express-complex-SDP-in-user-friendly-language">¶</a>
</h3>
<p>Since the objective function in complex SDP involves <strong>inner product</strong> operation, I would overload the <strong>dot</strong> operator so that it accepts a complex semidefinite matrix variable and an hermitian matrix. I would also need to extend the present API <strong>maximize/minimize</strong> for expressing real SDP optimization problem to complex SDPs such that methods it becomes easy for users to express SDPs in Convex.jl.</p>
<p>We would also need some more utilities such as:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>An utility function which would check if an expression is real or complex.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span><span class="nf"> type_of_expression</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">)</span>
    <span class="c"># There are set of rules to check if an expression is DCP compliant or not, similarly we would have set of rules</span>
    <span class="c"># which would decide of an expression is real or complex. For e.g - suppose if an expression has a complex </span>
    <span class="c"># Variable or a constant then it would be a complex expression.</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="s">"real"</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">false</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>An atom namely "conjugate" which would operate on an AbstractExpr to return its complex conjugate. We also need to note that conjugate and traspose operator would do the same thing on the real expression.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">type</span><span class="nc"> ConjugateAtom</span> <span class="o">&lt;:</span> <span class="n">AbstractExpr</span>
  <span class="n">head</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">id_hash</span><span class="p">::</span><span class="n">UInt64</span>
  <span class="n">children</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractExpr</span><span class="p">}</span>
  <span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">}</span>
    
    <span class="k">function</span><span class="nf"> ConjugateAtom</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_of_expression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>          <span class="c">#if x is real then the conjugate is equivalent to transpose</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(:</span><span class="n">transpose</span><span class="p">,</span> <span class="nb">hash</span><span class="p">(</span><span class="n">children</span><span class="p">),</span> <span class="n">children</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span>
            <span class="c">#set of steps to find the complex conjugate of x  </span>
        <span class="k">end</span>
    <span class="k">end</span>   
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>The present implementation of Convex.jl only allows constants to take real values. I would be required to extend the present implementation to allow the constants to take complex values as well. This would be done by modifying the "value" field of the Constant user-defined type.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># The following error occurs while assigning a complex value to a variable in Convex  </span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">()</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">6</span><span class="nb">im</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span class="p">:</span> <span class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span class="o">.&lt;=</span><span class="p">(::</span><span class="kt">Int32</span><span class="p">,</span> <span class="p">::</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Int32</span><span class="p">})</span>
<span class="c"># I would be required to modify the constant.jl file so that the variables accept the complex values as well.</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We would also need the following checks to validate user input:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Check that the right and the left hand side of the inequality contraint are real expression. This would be done by modifying the LtConstraint and GtConstraint constructors in contraints.jl file. We would be using the utility function "type_of_expression" described above to check if the lhs and the rhs of the constraints are real or not.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span><span class="nf"> LtConstraint</span><span class="p">(</span><span class="n">lhs</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">)</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">type_of_expression</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">type_of_expression</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="nb">error</span><span class="p">(</span><span class="s">"Either the lhs or rhs is complex expression"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">size</span> <span class="o">||</span> <span class="n">lhs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">size</span>
    <span class="k">elseif</span> <span class="n">rhs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span>
      <span class="nb">error</span><span class="p">(</span><span class="s">"Cannot create inequality constraint between expressions of size </span><span class="si">$(lhs.size)</span><span class="s"> and </span><span class="si">$(rhs.size)</span><span class="s">"</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">id_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">:(</span><span class="o">&lt;=</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">new</span><span class="p">(:(</span><span class="o">&lt;=</span><span class="p">),</span> <span class="n">id_hash</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">nothing</span><span class="p">)</span>
  <span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Ensure that the objective function is real. "objective" is one of the fields of user-defined type "Problem". Therefore, it would be required that I modify the constructor of type "Problem" so as to check whether the objective function is real or not before an instance of the type Problem is created.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span><span class="nf"> Problem</span><span class="p">(</span><span class="n">head</span><span class="p">::</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">objective</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">,</span>  
                   <span class="n">model</span><span class="p">::</span><span class="n">MathProgBase</span><span class="o">.</span><span class="n">AbstractConicModel</span><span class="p">,</span> <span class="n">constraints</span><span class="p">::</span><span class="n">Array</span><span class="o">=</span><span class="n">Constraint</span><span class="p">[])</span>
    <span class="k">if</span> <span class="n">type_of_expression</span><span class="p">(</span><span class="n">objective</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="s">"not yet solved"</span><span class="p">,</span> <span class="n">nothing</span><span class="p">,</span> <span class="n">model</span>
    <span class="k">else</span>
        <span class="nb">error</span><span class="p">(</span><span class="s">"Objective function must be real"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Ensure that the last entry of the Second Order Conic Constraint is real.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>All variables in exponential cones must be real. The exponential atoms include log, entropy and many others.</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># Lets look at one such atom log(x) and the code changes required to to make sure that the arguments are real.</span>
<span class="k">type</span><span class="nc"> LogAtom</span> <span class="o">&lt;:</span> <span class="n">AbstractExpr</span>
  <span class="n">head</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">id_hash</span><span class="p">::</span><span class="n">UInt64</span>
  <span class="n">children</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractExpr</span><span class="p">}</span>
  <span class="n">size</span><span class="p">::</span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">}</span>

  <span class="k">function</span><span class="nf"> LogAtom</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">)</span>
        <span class="c"># An if statement would be required to perform the check on the expression</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">type_of_expression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="nb">error</span><span class="p">(</span><span class="s">"Argument must be real"</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
            <span class="k">return</span> <span class="nb">new</span><span class="p">(:</span><span class="n">log</span><span class="p">,</span> <span class="nb">hash</span><span class="p">(</span><span class="n">children</span><span class="p">),</span> <span class="n">children</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">)</span> <span class="o">=</span> <span class="n">LogAtom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># overload the dot operator</span>
<span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">HermitianSemidefinite</span><span class="p">)</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">x</span><span class="o">'</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">HermitianSemidefinite</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">Value</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">'</span> <span class="o">*</span> <span class="n">Constant</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span><span class="nb">im</span><span class="p">;</span><span class="nb">im</span> <span class="mi">1</span><span class="p">]</span> <span class="c"># Initialized a Hermitian matrix</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">HermitianSemiDefinite</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>    <span class="c">#Created a complex positive semidefinite matrix </span>
<span class="n">objective</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">C</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">-</span><span class="nb">im</span><span class="p">;</span><span class="nb">im</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span>
<span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span> <span class="k">in</span> <span class="p">:</span><span class="n">HermitianSDP</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.-Implement-the-infrastructure-to-convert-the-complex-SDP-to-real-SDP-internally">3. Implement the infrastructure to convert the complex SDP to real SDP internally<a class="anchor-link" href="#3.-Implement-the-infrastructure-to-convert-the-complex-SDP-to-real-SDP-internally">¶</a>
</h3>
<p>In order to achieve this step, it would be required to make our Convex.jl package capable of distinguishing between real SDPs and complex SDPs. The current implementation exposes an API <strong>"minimize/maximize"</strong> to the user and creates an instance of an user-defined type <strong>Problem</strong>. I plan to make changes in the minimize/maximize API making it capable of distinguishing between real and complex SDPs. So, when the SDP is real, the package would use the existing the implementation and create an instance of "Problem" as usual but when the SDP is complex, first the package would convert the SDP into real SDP using the transformation $\tau$ described in the "Execution" section and then create an instance of "Problem". The end result of this step would be an equivalent real SDP of the given complex SDP.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># Redefining minimize/maximize API to distinguish between Real and Complex SDPs</span>

<span class="k">function</span><span class="nf"> </span><span class="o">(</span><span class="n">objective</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">,</span> <span class="n">constraints</span><span class="p">::</span><span class="n">Constraint</span><span class="o">...</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">objective</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="p">:</span><span class="n">complex</span> <span class="c"># In the if condition, we use the unique representation of the complex SDP</span>
        <span class="n">convert_to_real</span><span class="p">(:</span><span class="n">minimize</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">collect</span><span class="p">(</span><span class="n">constraints</span><span class="p">))</span>
    <span class="k">else</span>
        <span class="n">Problem</span><span class="p">(:</span><span class="n">minimize</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">collect</span><span class="p">(</span><span class="n">constraints</span><span class="p">))</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c">#defining a new function which would take an complex SDP and convert to real SDP using the transformation tau</span>
<span class="k">function</span><span class="nf"> convert_to_real</span><span class="p">(</span><span class="n">head</span><span class="p">::</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">objective</span><span class="p">::</span><span class="n">AbstractExpr</span><span class="p">,</span> <span class="n">constraints</span><span class="p">::</span><span class="n">Array</span><span class="o">=</span><span class="n">Constraint</span><span class="p">[])</span>
    <span class="c"># These steps would convert the problem to real SDP</span>
    <span class="c"># After the conversion to real SDP, we would create an instance of type Problem</span>
    <span class="n">Problem</span><span class="p">(:</span><span class="n">minimize</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">collect</span><span class="p">(</span><span class="n">constraints</span><span class="p">))</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="4.-Solve-the-real-SDP-using-existing-backend-solvers-via-the-MathProgBase-interface">4. Solve the real SDP using existing backend solvers via the MathProgBase interface<a class="anchor-link" href="#4.-Solve-the-real-SDP-using-existing-backend-solvers-via-the-MathProgBase-interface">¶</a>
</h3>
<p>Now, when we have an equivalent real SDP of the problem, I plan to use the existing implementation in solution.jl which uses methods from MathProgBase package to convert the problem to conic form(since the converted SDP is already in the conic form, we may not need the conversion to conic form), load the problem into solver and optimize it. The <strong>"solve!"</strong> would be used to solve the SDP and a new instance of user-defined type <strong>"Solution"</strong> is created which has value of the primal and dual variables, status(Optimal, Unbounded), optimum value of the objective function stored in it in different fields. Now, when we have the solution of the real SDP, the next step is to transform the solution of the real SDP to its corresponding complex SDP. Also, the default setting in Convex.jl prints the output from solver(which we disable by passing in verbose=0), I would also need to change the setting so that the output from the solver is not displayed by default as we would not want the solution of the real SDP to be outputted to the user by default.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># Given below is the function in the existing source code which I plan to use to solve the transformed real SDP. </span>
<span class="k">function</span><span class="nf"> solve</span><span class="o">!</span><span class="p">(</span><span class="n">problem</span><span class="p">::</span><span class="n">Problem</span><span class="p">;</span>
                <span class="n">warmstart</span><span class="o">=</span><span class="n">false</span><span class="p">,</span> <span class="n">check_vexity</span><span class="o">=</span><span class="n">true</span><span class="p">)</span>

<span class="c">#Checking the vexity of the Problem</span>
  <span class="k">if</span> <span class="n">check_vexity</span>
    <span class="n">vex</span> <span class="o">=</span> <span class="n">vexity</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
  <span class="k">end</span>
    
<span class="c"># Convert the problem to the conic form </span>
<span class="c"># Since we have formulated the complex SDP in such a way that the existing problem is already in conic form. </span>
<span class="c"># The step below can be skipped which would lead to less computation time.</span>
  <span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cones</span><span class="p">,</span> <span class="n">var_to_ranges</span><span class="p">,</span> <span class="n">vartypes</span><span class="p">,</span> <span class="n">conic_constraints</span> <span class="o">=</span> <span class="n">conic_problem</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
    
<span class="c"># This method call "loadproblem" method from MathProgBase which in turn loads the problem to the existing conic solvers</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">model</span>
  <span class="n">load_problem!</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cones</span><span class="p">,</span> <span class="n">vartypes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">warmstart</span>
    <span class="n">set_warmstart!</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">var_to_ranges</span><span class="p">)</span>
  <span class="k">end</span>
  
<span class="c"># The package uses MathProgbase interface to call the existing methods for optimization</span>
  <span class="n">MathProgBase</span><span class="o">.</span><span class="n">optimize!</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c"># The method below assigns the values to different fields in "Solution" type and displays it to the user</span>
  <span class="n">populate_solution!</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">var_to_ranges</span><span class="p">,</span> <span class="n">conic_constraints</span><span class="p">)</span>
  <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">problem</span><span class="o">.</span><span class="n">status</span><span class="o">==</span><span class="p">:</span><span class="n">Optimal</span><span class="p">)</span>
    <span class="n">warn</span><span class="p">(</span><span class="s">"Problem status </span><span class="si">$(problem.status)</span><span class="s">; solution may be inaccurate."</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="5.-Convert-the-solution-of-the-real-SDP-into-corresponding-complex-SDP">5. Convert the solution of the real SDP into corresponding complex SDP<a class="anchor-link" href="#5.-Convert-the-solution-of-the-real-SDP-into-corresponding-complex-SDP">¶</a>
</h3>
<p>This step is exactly reverse of step 3. In this step, we use the transformation $\tau^{-1}$ to obtain the solution of the complex SDP from the solution of the real SDP which is obtained in step 4. Lets us assume that the primal value of the variables of the real SDP is stored in temporary variable $Y$ which is a square matrix of order $2n$. As from the transformation $\tau^{-1}$, it can be easily verified that first $n$ columns of first $n$ rows contain the real part of the complex matrix $X$ and the next $n$ columns contain negative the imaginary part of the matrix $X$. Also, the optimum value of the complex SDP is half the optimum value of the complex SDP. Thus, I would need to implement a new function which would take the primal values and the optimum values of the real SDP and convert to the corresponding complex SDP. This would be done by creating a function which would take the user-defined type <strong>"Solution"</strong> (this contains the solution for the real SDP) as an argument and convert it to complex-domain solution. I would also be required to make our solver intelligent so that it could distinguish between real and complex-domain SDPs. This would be done by creating a new field <strong>"domain"</strong> in the user-defined type <strong>"Solution"</strong> which would take values as either <strong>real or complex</strong>. If the the field <strong>domain</strong> contains value complex then the transformation $\tau^{-1}$ would be called else no need.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># Redefining the user-defined type Solution</span>
<span class="k">type</span><span class="nc"> Solution</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span>
    <span class="n">domain</span>                               <span class="c"># "domain" field would either take the value real or complex</span>
  <span class="n">primal</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
  <span class="n">dual</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
  <span class="n">status</span><span class="p">::</span><span class="n">Symbol</span>
  <span class="n">optval</span><span class="p">::</span><span class="n">T</span>
  <span class="n">has_dual</span><span class="p">::</span><span class="kt">Bool</span>
<span class="k">end</span>

<span class="c">#defining a new function which would take the user-defined type "Solution", check if the solution is for transformed</span>
<span class="c"># SDP. If yes, it would use inverse transformation to get the complex-domain solution.</span>
<span class="k">function</span><span class="nf"> real_to_complex</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">Solution</span><span class="p">)</span>
    <span class="k">if</span>
        <span class="n">s</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span><span class="s">"real"</span>
        <span class="k">return</span>
    <span class="k">else</span>
        <span class="c"># use the inverse transformation to obtain complex-domain solution. The complex-domain solution</span>
        <span class="k">end</span> 
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="6.-Output-the-complex-domain-solution-to-the-user">6. Output the complex domain solution to the user<a class="anchor-link" href="#6.-Output-the-complex-domain-solution-to-the-user">¶</a>
</h3>
<p>Now, when we have the complex-domain solution of the complex SDP. I would be using the existing machinery in Convex.jl to output the optimum value of the objective function and the value of the primal variables.</p>
<!-- **Note- ** The **"evaluate"** method in the existing atoms can handle the complex variables. But some atoms are only defined over real domain (for example- max(x,0)) thus, I would need to append the warning messages to such atoms in case the users by mistake call the evaluate method with complex argument. --->
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [ ]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="c"># solve the complex SDP</span>
<span class="n">solve!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">optval</span> <span class="c"># Displays the optimum values of the complex SDP</span>
<span class="n">p</span><span class="o">.</span><span class="n">status</span> <span class="c"># Displays whether the optimum point could be reached or not</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Timeline-(tentative)">Timeline (tentative)<a class="anchor-link" href="#Timeline-(tentative)">¶</a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Community-Bonding-period-(22nd-April---22nd-May)">Community Bonding period (22nd April - 22nd May)<a class="anchor-link" href="#Community-Bonding-period-(22nd-April---22nd-May)">¶</a>
</h4>
<p>My summer vacation will start from 30th of April. During this period, I would want to get myself more familiarized with the source code of Convex.jl. I have in particular 2 issue in mind which I would like to send the pull request to namely:</p>
<ul>
<li>
<code>Issue multiplying expressions with matrices.</code><a href="https://github.com/JuliaOpt/Convex.jl/issues/122">#122</a>
</li>
</ul>
<p>I believe solving the above issue would help me strengthen my understanding of source code and make myself comfortable with contributing to the package.</p>
<ul>
<li>
<code>Missing kron for convex programming variables.</code><a href="https://github.com/JuliaOpt/Convex.jl/issues/57">#57</a>
</li>
</ul>
<p>This would be the first step towards supporting complex numbers in Convex.jl, <strong>kron</strong> atom is used in Chebychev design of an FIR filter given a desired frequency response. Thus implementing this feature would make Convex.jl useful in the applications related to filter design</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-1">Week 1<a class="anchor-link" href="#Week-1">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Implement support for complex variable and complex SDP in Convex.jl</em></p>
<p>I plan to implement the 6 step procedure described in the "Execution" section on weekly basis. We would only be able to merge the code into the existing package after all the 6 steps have been implemented. I would start by making changes in variable.jl file. The end outcome of this week would be that the users would be able to declare a variable as complex-domain variable.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-2">Week 2<a class="anchor-link" href="#Week-2">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Overload dot operator and extend minimize/maximize API</em></p>
<p>In this week, I would overload the multiply dot operator to support complex multiplication and extend the present API for expressing real SDPs to complex SDPs such that it becomes easy for users to express complex SDPs in Convex.jl.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-3-and-4">Week 3 and 4<a class="anchor-link" href="#Week-3-and-4">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Implement new functions for transformation $\tau$</em></p>
<p>These 2 weeks would be required to implement step 3 by making changes in problem.jl file. I would also write new routines to convert complex SDPs to real SPDs.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-5">Week 5<a class="anchor-link" href="#Week-5">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Integration of existing solvers via MathProgBase interface</em></p>
<p>During this week, I would work to integrate the existing solvers like SCS, Mosek via MathProgBase interface to solve the transformed real SDP, I would also need to change the default setting in Convex.jl so that the output from the solver is not outputted to the user.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-6-and-7">Week 6 and 7<a class="anchor-link" href="#Week-6-and-7">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Convert the solution of the real SDP into corresponding complex SDP</em></p>
<p>During these 2 weeks, I implement a new function which would take the primal values and the optimum values of the real SDP and convert to the corresponding complex SDP using the transformation $\tau^{-1}$.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-8">Week 8<a class="anchor-link" href="#Week-8">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Display the complex domain solution to the user</em></p>
<p>During this week, I would be writing codes to use the existing machinery in Convex.jl to output the optimum value of the objective function and the value of the primal variables to the users once the optimization is complete.</p>
<p>At the end of this week, the support for the complex-domain problems in Convex.jl would be ready for testing for the Julia community.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-9-and-10">Week 9 and 10<a class="anchor-link" href="#Week-9-and-10">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Documentation, Notebooks, Bug fixes</em></p>
<p>By this time I will make sure that none of the above implementations has introduced any bug and are complete by documentation as well as testing. I will extend this period to my Future Work as writing example notebooks and
preparing for a major release of the package.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Week-11-and-12">Week 11 and 12<a class="anchor-link" href="#Week-11-and-12">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Incorporate changes from the feedback given by Julia community and work on presolve routine</em></p>
<p>During these two weeks, I plan to work on the suggestions given by the Julia community about the new feature I would be adding. I would try to have extensive discussion with the community during this period and incorporate changes so as to make Convex.jl more robust and user-friendly and ready to be released. If time permits, I also plan to understand the existing SDP solvers like SCS and Mosek in detail and try to figure what could be better ways than the existing ones so that we could make our presolve routine better. I would also be required to read and understand the existing presolve routines for Linear Programming Problems so that I could think on similar lines.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="End-Term-evaluation">End-Term evaluation<a class="anchor-link" href="#End-Term-evaluation">¶</a>
</h4>
<p><strong>Goal:</strong> <em>Working towards the publication</em></p>
<p>Buffer period for any lagging work. I also aim to work towards writing a research paper during this period under the guidance of my mentors.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">References<a class="anchor-link" href="#References">¶</a>
</h2>
<p>[1]. Approximation algorithms for MAX-3-CUT and other problems via complex semidefinite programming. <a href="http://www.sciencedirect.com/science/article/pii/S0022000003001454">http://www.sciencedirect.com/science/article/pii/S0022000003001454</a></p>
<p>[2]. Invariant semidefinite programs. <a href="http://arxiv.org/pdf/1007.2905v2.pdf">http://arxiv.org/pdf/1007.2905v2.pdf</a></p>
<p>[3]. Convex Optimization in Julia. <a href="http://arxiv.org/pdf/1410.4821.pdf">http://arxiv.org/pdf/1410.4821.pdf</a></p>
<p>[4]. <a href="https://github.com/JuliaOpt/Convex.jl/issues/103">#103</a> Support for complex variables.</p>
<p>[5]. <a href="https://github.com/cvxgrp/cvxpy/issues/191">#191</a> Add complex variables.</p>
<p>[6]. <a href="http://nbviewer.jupyter.org/github/cvxgrp/cvxpy/blob/master/examples/notebooks/WWW/fir_chebychev_design.ipynb">Chebychev design of an FIR filter given a desired frequency response</a></p>
<!--- ipython nbconvert --to FORMAT notebook.ipynb --->
</div>
</div>
</div>
    </div>
  </div>

    </div>
            <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});</script><script src="../../assets/js/mathjax.js"></script></article>
</div>
            </div>
        </div>
        <button class="btn btn-fab btn-raised btn-material-green btn-footer" data-toggle="modal" data-target="#footer-dialog">
            <i class="mdi-communication-message"></i>
        </button>
        <div id="footer-dialog" class="modal fade" tabindex="-1">
          <div class="modal-dialog">
            <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
                <h4 class="modal-title">Ayush Pandey</h4>
                <div>
                    

                </div>
                <hr>
</div>
              <div class="modal-body">
                    Contents © 2016         <a href="mailto:ayush.pandey@iitkgp.ac.in">Ayush Pandey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
              </div>
              <div class="modal-footer">
                <button class="btn btn-primary" data-dismiss="modal">Ok</button>
              </div>
            </div>
          </div>
        </div>
        <div class="source-button">
    <!--<a class="btn btn-fab btn-raised btn-material-indigo" target="_blank" href="/stories/gsoc16-proposal/index.ipynb" title="Source">
        <i class="mdi-file-cloud-download"></i>
    </a> -->

        </div>
        <div class="kc_fab_wrapper"></div>
</div>

            <script src="../../assets/js/all-nocdn.js"></script><!-- Social buttons --><div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="https://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script><!-- End of social buttons --><script>
                var links = [
                        {
                            "icon": "<i class='fa fa-share-square-o'></i>",
                            "bgcolor": "#F44336",
                        },
                        {
                            "icon": "<i class='fa fa-twitter'></i>",
                            "target": "_blank",
                            "bgcolor": "#55ACEE",
                            "color": "#fffff",
                            "url": "https://twitter.com/",
                        },
                        {
                            "icon": "<i class='fa fa-github-square'></i>",
                            "target": "_blank",
                            "bgcolor": "#666666",
                            "color": "#fffff",
                            "url": "https://github.com/",
                        },
                        {
                            "icon": "<i class='fa fa-facebook'></i>",
                            "target": "_blank",
                            "bgcolor": "#3B5998",
                            "color": "#fffff",
                            "url": "https://www.facebook.com",
                        },
                ];

            $(document).ready(function() {
                // This command is used to initialize some elements and make them work properly
                $.material.init();
                    $('.kc_fab_wrapper').kc_fab(links);
            });

            $(window).on("resize", function() {
                $("html, body").height($(window).height());
                $(".main, .menu").height($(window).height() - $(".header-panel").outerHeight() - 76 ); // footer margin: $("footer.footer").outerHeight()
                $(".posts-material").height($(window).height());
            }).trigger("resize");
        </script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
